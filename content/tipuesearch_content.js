var tipuesearch = {"pages": [{'title': '關於', 'text': '這是 https://github.com/mdecourse/cmstemplate \n 目前的 cmsimde 在編輯器下方新增一個 csave 按鈕, 意即 collabrative save, 當動態網際管理系統在多人同時維護登入維護網頁內容時, 編輯各頁面時段, 該頁面可能已經改版, 因此使用 csave 按鈕存檔時, 會導入當下最新的該頁面內容, 並試圖與編輯中的頁面內容進行合併. \n 使用 csave 按鈕存檔無法刪除頁面資料. \n 使用 Edit All 模式, 無法使用 csave 按鈕（尚未測試). \n 123 \n 測試 \n 測試 \n ???? \n', 'tags': '', 'url': '關於.html'}, {'title': '上課內容', 'text': '', 'tags': '', 'url': '上課內容.html'}, {'title': 'W1', 'text': '網際內容管理課程簡介 \n https://youtu.be/hZMriptiTU4 \n 網際內容管理將從學校教務主機, 以 Flask 與 bs4 擷取出各種相關資料作為開端, 以下為初步流程介紹: \n https://youtu.be/37l2T6lF2oo \n 為從\xa0 http://a.kmol.info:88 \xa0 取下 Python 3.9.1 版的可攜程式系統, 特別將需要 @gm 權限的兩階段程式系統, 從 @gm 移動到 \xa0 http://a.kmol.info:88 , 其中使用 sftp 與 ssh 對 a.kmol.info 進行連線: \n https://youtu.be/OaOdFv3EbIs \n', 'tags': '', 'url': 'W1.html'}, {'title': 'W2', 'text': '\xa0說明 KMOLab 基本概念就是希望機械設計工程師能夠善用計算機程式與網路, 讓產品開發流程更有效率. \n https://youtu.be/9-Qu-xwJmRE \n 說明與 cmsimde 編輯及轉靜態網頁有關的認知 \n https://youtu.be/s5ty-MpnK7c \n 說明 topic0 執行動機以及自選組員後所衍生相關資料擷取問題的因應及處理 \n', 'tags': '', 'url': 'W2.html'}, {'title': 'W3', 'text': '自選組員 6 人一組 \n', 'tags': '', 'url': 'W3.html'}, {'title': 'W4', 'text': '1. 各組根據 W1 - W3 的課程內容從 \xa0 https://qry.nfu.edu.tw/ \xa0 以網際程式截取四技設一甲班上各課程的開課時段與修課人員名單, 並使用 \xa0 https://github.com/mdecourse/nfulist \xa0 程式架構, 將分組程式送到 \xa0 Heroku \xa0 伺服. \n http://mde.tw/cp2020/content/Heroku.html \n http://mde.tw/cp2020/content/nfu-project.html \n http://mde.tw/cp2020/content/scissor-rock-paper.html \n 2. \xa0 http://mde.tw/wcmj2021/content/W4.html \n 3. 請根據 \xa0 https://qry.nfu.edu.tw/classroom.php \xa0 中有關機械設計工程系相關的實習實驗室排課時數, 按照排課時數多寡, 列出各實習實驗室的總排課時數表. \n 4. 請問從各學制的班級名條 ( https://qry.nfu.edu.tw/classlist.php ) 統計, 可以算出各學制 2021 Spring 總註冊人數嗎? \n 練習英文打字與寫作編輯: \n 請將下列 paper 重新打字整理為 .txt 純文字檔案, 之後再利用 LaTeX 整理為 pdf 檔案. \n 1990_evaluating_the_use_of_cad_systems_in_mechanical_design_engineering.pdf \n', 'tags': '', 'url': 'W4.html'}, {'title': 'W5', 'text': '假如您使用的 cmsimde 並不是最新版本, 可以設法進入 cmsimde 子目錄後, 以 git pull origin master 拉回最新版本的程式碼, 並且注意是否 cmsimde/up_dir 目錄中有檔案更新, 若是則必須將這些隨著版次更新的檔案, 從 up_dir 複製到倉儲根目錄. \n \n 為了要讓各組組員更清楚網際內容管理課程內容, 以及期中簡報必須涵蓋的內容,\xa0 特別將 W1-W4 與課程相關的頁面及內容加以說明. \n \n 說明如何利用 Putty 設定以 SSH 將近端版本推送至 Github \n \n 實習目的: \n \n 利用網際模組擷取資料 ( Python requests ) \n 利用 bs4 擷取網頁資料 \n 利用 Flask 編寫網際程式 \n 利用 Heroku 部署網際程式 \n 利用 Ubuntu 虛擬主機作為伺服器 \n \n 先看懂 \xa0 https://github.com/mdecourse/scissor-rock-paper2/blob/main/wsgi.py \n request . args . get ( \'user\' ) 以 GET 方式取得 user 出拳變數值 \n 電腦出拳以亂數取值 \n 兩者比較後傳回超文件顯示比賽結果 \n 部署到 Heroku 需要 \xa0 requirements.txt , \xa0 runtime.txt \xa0 與 \xa0 Procfile . \n 接著請試著透過 \xa0 http://mde.tw/lab/content/Heroku.html \xa0 與 \xa0 http://mde.tw/cp2020/content/Heroku.html \xa0 的導引, 將 \xa0 Topic0 \xa0 中的機械設計系實驗室排課時間表程式部署到 Heroku. 至於個人 Github 靜態網站也可以同步一份到 Heroku. \n Beautifulsoup 參考教材: \n beautifulsoup.pdf \n WebScraping_with_bs4.pdf \n beautiful_soup_tutorial.pdf \n 2019_beautifulsoup_document.pd \n Flask 參考教材: \n flask.pdf \n flask_tutorial.pdf \n flask_document.pdf \n 2021_flask_document.pdf \n https://realpython.com/primer-on-python-decorators/ \n https://www.programiz.com/python-programming/decorator \n https://www.python-course.eu/python3_decorators.php \n Python has a feature called decorators to add functionality to an existing code. This is also called metaprogramming because a part of the program tries to modify another part of the program at compile time. \n Decorators allow us to wrap another function in order to extend the behavior of the wrapped function, without permanently modifying it. \n Heroku 參考教材: \n http://mde.tw/cp2020/content/Heroku.html \n http://mde.tw/cp2020/content/scissor-rock-paper.html \xa0 ( https://scissor-rock-paper.herokuapp.com ) \n https://github.com/mdecourse/scissor-rock-paper2 \xa0 ( https://scissor-rock-paper2.herokuapp.com/ ) \n heroku.pdf \n 2017_web_apps.pdf \n Ubuntu server 參考教材 . \n Topic 0 \xa0 已經列出兩組可以從學校教務主機擷取資料的程式, 分別可以根據學期代號與班級代號取出班級排課表, 還有利用學期代號與實習實驗室代號擷取排客時間表. \n 接下來實習的目標是希望寫一組程式可以擷取機械設計工程系各實習實驗室排課表, 並且統計各實驗室每週排課總時數. \n 我們先來看 \xa0 Python requests \xa0 的用法: \n W5_requests_ex1.py \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n \n \n \n import   requests \n \xa0 \n r  =   requests.get( "https://mde.tw" ) \n print ( "status_code:" , r.status_code) \n print ( "content-type:" , r.headers[ \'content-type\' ]) \n print ( "encoding:" , r.encoding) \n print ( "text:" , r.text) \n \n \n \n \n \n \n \n 要看懂下列程式, 必須知道何謂 \xa0 html entity , 而且要會使用 requests.post() 與 bs4.BeautifulSoup() \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n 33 \n 34 \n 35 \n 36 \n 37 \n 38 \n 39 \n 40 \n 41 \n 42 \n 43 \n 44 \n 45 \n 46 \n 47 \n 48 \n 49 \n 50 \n 51 \n 52 \n 53 \n 54 \n 55 \n 56 \n 57 \n 58 \n 59 \n 60 \n 61 \n 62 \n 63 \n 64 \n 65 \n 66 \n 67 \n 68 \n 69 \n \n \n \n import   requests \n import   bs4 \n # for os.environ and os.system() \n import   os \n # for geting html file path \n import   pathlib \n \xa0 \xa0 \n # for pythn 3.9 \n proxy  =   \'http://[2001:288:6004:17::69]:3128\' \n \xa0 \xa0 \n os.environ[ \'http_proxy\' ]  =   proxy  \n os.environ[ \'HTTP_PROXY\' ]  =   proxy \n os.environ[ \'https_proxy\' ]  =   proxy \n os.environ[ \'HTTPS_PROXY\' ]  =   proxy \n \xa0 \xa0 \n \'\'\' \n url:\xa0 \'class_ajax.php\', \n data: { pselyr: pselyr, pselclss: pselclss \n \'\'\' \n semester  =   \'1092\' \n classno  =   \'42311\' \n column  =   True \n \xa0 \xa0 \n if   semester  = =   None : \n \xa0\xa0\xa0\xa0 semester  =   \'1091\' \n if   classno  = =   None : \n \xa0\xa0\xa0\xa0 # 42311 is 設一甲 \n \xa0\xa0\xa0\xa0 classno  =   \'42311\' \n \xa0\xa0\xa0\xa0\xa0 \xa0 \n headers  =   { \'X-Requested-With\' :  \'XMLHttpRequest\' } \n \xa0 \xa0 \n url  =   \'https://qry.nfu.edu.tw/class_ajax.php\' \n post_var  =   { \'pselyr\' : semester,  \'pselclss\' : classno} \n \xa0 \xa0 \n result  =   requests.post(url, data  =   post_var, headers  =   headers) \n \xa0 \xa0 \n # result.content 傳回 binary 資料 \n # soup = bs4.BeautifulSoup(result.content, \'lxml\') \n # result.text 傳回純文字資料 \n soup  =   bs4.BeautifulSoup(result.text,  \'lxml\' ) \n \xa0 \xa0 \n # 先除掉所有 anchor \n for   a  in   soup.findAll( \'a\' ): \n \xa0\xa0\xa0\xa0 # bs3 語法 \n \xa0\xa0\xa0\xa0 #a.replaceWithChildren() \n \xa0\xa0\xa0\xa0 # bs4 語法, 將標註與內容拆開 \n \xa0\xa0\xa0\xa0 a.unwrap() \n \xa0 \xa0 \n # 根據輸出設定, 取出 class=\'tbcls\' 的 table 資料 \n table  =   soup.find( \'table\' , { \'class\' :  \'tbcls\' }) \n \xa0 \xa0 \n # 重建 table, 設定邊線為 1 pixel \n output  =   "<table border=\'1\'>" \n \xa0 \xa0 \n for   i  in   table.contents: \n \xa0\xa0\xa0\xa0 # 利用 replace 復原\xa0  \n \xa0\xa0\xa0\xa0 # https://www.w3schools.com/html/html_entities.asp \n \xa0\xa0\xa0\xa0 # https://developer.mozilla.org/en-US/docs/Glossary/Entity \n \xa0\xa0\xa0\xa0 output  + =   str (i).replace( "&amp;nbsp" ,  " " ) \n output  + =   "</table>" \n # print(output) \n # 將 output 寫入 w1_class_local.html \n with  open ( "w1_class_local.html" ,  "w" , encoding = "utf-8" ) as  file : \n \xa0\xa0\xa0\xa0 file .write(output) \n # 利用 os.system() 以 default browser 開啟 w1_class_local.html \n filePath  =   pathlib.Path(__file__).parent.absolute() \n #print(filePath) \n # set firefox as default browser and start url to open html file \n os.system( "start file:///"   +   str (filePath)  +   "\\\\w1_class_local.html" ) \n \n \n \n \n \n \n \n 以上在 CMSMDE 列出程式碼, 有一個技巧, 針對 \xa0 Html entity \xa0 符號必須將 & 表示為 &amp; 否則在頁面程式引用時無法正確顯示出原始碼內容. \n Flask example: \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n 33 \n 34 \n \n \n \n from   flask  import   Flask, request \n from   datetime  import   datetime \n import   os \n \xa0 \n # for pythn 3.9 \n proxy  =   \'http://[2001:288:6004:17::69]:3128\' \n \'\'\'  \n os.environ[\'http_proxy\'] = proxy  \n os.environ[\'HTTP_PROXY\'] = proxy \n os.environ[\'https_proxy\'] = proxy \n os.environ[\'HTTPS_PROXY\'] = proxy \n \'\'\' \n app  =   Flask(__name__) \n \xa0 \n # https://realpython.com/primer-on-python-decorators/ \n @app .route( \'/\' ) \n def   hello(): \n \xa0\xa0\xa0\xa0 # 若取不到 name 則 name = None \n \xa0\xa0\xa0\xa0 name  =   request.args.get( \'name\' ) \n \xa0\xa0\xa0\xa0 if   name  = =   None : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 name  =   "test" \n \xa0\xa0\xa0\xa0 # https://realpython.com/python-formatted-output/ \n \xa0\xa0\xa0\xa0 return   HELLO_HTML. format ( \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 name,  str (datetime.now())) \n \xa0 \n HELLO_HTML  =   """ \n \xa0\xa0\xa0\xa0 <html><body> \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 <h1>Hello, {0}!</h1> \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 現在時間為: {1}. \n \xa0\xa0\xa0\xa0 </body></html>""" \n \xa0 \n if   __name__  = =   "__main__" : \n \xa0\xa0\xa0\xa0 # Launch the Flask dev server \n \xa0\xa0\xa0\xa0 app.run(host = "localhost" , debug = True ) \n \n \n \n \n \n \n \n', 'tags': '', 'url': 'W5.html'}, {'title': 'W6', 'text': '步驟一: \xa0 ( 建立 Heroku 帳號 ) 進入 \xa0 https://heroku.com , 利用學校配發的 @gm 登記一個 Heroku 帳號, 關鍵在於密碼設定必須要至少 8 個字元, 且字元中必須包含符號, 英文字母及數字,\xa0 並且登記後要進入 @gm 帳號進行確認後才能開通 Heroku 帳號. \n 完成帳號登記後, 必須知道目前 Heroku 只允許免費建立五個應用程式, 且每個程式的最大容量為 500MB. \n 步驟二: \xa0 ( 建立 Heroku app ) 登入 Heroku 後, 先以 s + 學號 建立第一個 app, 完成後, 將可至 https://s學號.herokuapp.com 連線取得網站最初內容. \n 步驟三: \xa0 (下載 Heroku CLI) 從 \xa0 http://a.kmol.info:88/heroku.7z \xa0 下載 Heroku cli 程式檔案, 解開至隨身碟 Y: 所在位置或者是 Hybrid 設定的位置. \n 步驟四: \xa0 ( 修改命令搜尋路徑 ) 修改隨身系統的啟動批次檔案, 讓 Windows 的命令視窗中可以執行 heroku.exe, 或者稱作"設法將 heroku.exe 所在目錄位置, 設為 Windows 搜尋路徑之一". \n 重新啟動已經納入可執行 heroku.exe 的隨身碟 start_ipv6.bat 或 start_ipv4.bat \n 步驟五: \xa0 ( 測試 heroku 執行 ) 測試是否能夠在修改後的命令列中執行 heroku.exe, 輸入 heroku version 若回應所使用的版本表示上述路徑設定已經成功. \n 步驟六: \xa0 ( 設定 heroku 代理主機 ) 先前我們已經知道網路的應用包含 client 與 server, 不同 client 採用不同的 proxy 設定與 server 連線, 其中 firefox 作為 WWW 網路協定的 client, 有其自己的網路 Proxy 設定, 也可以直接使用操作系統的 Proxy 設定. \n Chrome 作為 WWW 網路協定的 client, 目前 Windows 下的最新版, 只能使用操作系統的 Proxy 設定. \n 而 git 作為 git client 與 github server 連線的 Proxy 設定, 則寫在 y:\\home_ipv6 下的 .giconfig 中,\xa0 以 git config --global http.proxy "http://your_proxy:port" 進行設定. \n 相同的道理 heroku cli 作為 \xa0 https://heroku.com \xa0 伺服器的 client 端, 也有其 Proxy 的設定方式, 也就是在 start_ipv6.bat 中加入: \n \n \n \n \n \n \n 1 \n 2 \n 3 \n \n \n \n REM  for   heroku login \n set HTTP_PROXY=http: //[2001:288:6004:17::53]:3128 \n set HTTPS_PROXY=http: //[2001:288:6004:17::53]:3128 \n \n \n \n \n \n \n \n 步驟七: \xa0 ( 設定同步倉儲 ) 針對利用 Heroku 同步 Github Pages 上的網站內容, 只需要透過 git remote add (Heroku 指令為 heroku git:remote -a heroku_倉儲_名稱, 之後只要在 heroku login 狀態下, 可以直接利用 git push) 在近端設定一個連線到 Heroku 倉儲的代號, 就能在每次更新 Github Pages 倉儲後, 再將內容同步至 Heroku. 網際內容管理課程將使用兩種 Heroku app 設定, 也就是靜態網頁與動態網頁: \n 靜態網頁 - 採用 php 方式部署, 讓 Heroku 將靜態網頁視為 PHP 程式, 利用 index.php 跳轉到 index.html \n 動態網頁 - 讓 Heroku 執行 cmsimde/wsgi.py 的方式進行雲端伺服. \n 步驟八: \xa0 ( 以 git 進行提交推送 ) 利用 heroku git:remote -a 設定的同步倉儲其推送名稱內定為 "heroku", 使用者只要使用 git push heroku 就可以將改版內容推送到對應的 Heroku app 倉儲. \n 指令操作步驟: \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n \n \n \n # 以 interactive 模式登入 Heroku, 完成後產生 y:\\home_ipv6\\_netrc \n heroku login  - i \n # 針對已經登入的 Heroku 帳號下的 taiwan-01 app, 設為此倉儲的 remote 同步倉儲, 且在倉儲中會自建名稱為 heroku 的 remoate site. \n heroku git:remote  - a taiwan - no1 \n \n \n \n \n \n \n \n 上述步驟完成後的 Heroku 網站: \xa0 https://taiwan-no1.herokuapp.com \n 參考資料: \n https://github.com/twtrubiks/Deploying-Flask-To-Heroku \n https://gist.github.com/bradtraversy/0029d655269c8a972df726ed0ac56b88 \n https://github.com/gmolveau/flask-sqlalchemy-heroku \n', 'tags': '', 'url': 'W6.html'}, {'title': 'W7', 'text': '之前的 git 倉儲都是先在 Github 網際平台上建立後, 再設法 git clone 到近端改版, 但是這樣的前提是在 Github 建立倉儲時, 至少新增一個檔案 README.md,\xa0 但是假如在 Github 建立一個空倉儲則通常會建議使用者先在近端以 git init 產生一個空的 git 倉儲後, 納入改版資料然後再透過 git remote add 設定與遠端的 Github 倉儲 URL 進行對應. \n 而通常針對特定倉儲的 defualt 遠端 URL 連結的 git remote add 會以 origin 作為代號. \n 以下列 nfumde 近端的 .git/config 設定檔案為例: \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n \n \n \n [core] \n \xa0\xa0\xa0\xa0 repositoryformatversion = 0 \n \xa0\xa0\xa0\xa0 filemode =  false \n \xa0\xa0\xa0\xa0 bare =  false \n \xa0\xa0\xa0\xa0 logallrefupdates =  true \n \xa0\xa0\xa0\xa0 symlinks =  false \n \xa0\xa0\xa0\xa0 ignorecase =  true \n [remote  "origin" ] \n \xa0\xa0\xa0\xa0 url = git@github.com:mdecourse/nfumde.git \n \xa0\xa0\xa0\xa0 fetch = +refs/heads/*:refs/remotes/origin/* \n [remote  "heroku" ] \n \xa0\xa0\xa0\xa0 url = https: //git.heroku.com/nfumde.git \n \xa0\xa0\xa0\xa0 fetch = +refs/heads/*:refs/remotes/heroku/* \n [branch  "main" ] \n \xa0\xa0\xa0\xa0 remote = origin \n \xa0\xa0\xa0\xa0 merge = refs/heads/main \n \n \n \n \n \n \n \n 當使用者在命令列中的特定目錄中以 git init 建立 .git 目錄時, .git/config 中只會有以下資料, 表示此目錄為 git 空倉儲, 尚未與遠端 Github 有任何對應: \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n \n \n \n [core] \n \xa0\xa0\xa0\xa0 repositoryformatversion = 0 \n \xa0\xa0\xa0\xa0 filemode =  false \n \xa0\xa0\xa0\xa0 bare =  false \n \xa0\xa0\xa0\xa0 logallrefupdates =  true \n \xa0\xa0\xa0\xa0 symlinks =  false \n \xa0\xa0\xa0\xa0 ignorecase =  true \n \n \n \n \n \n \n \n 當使用者在該倉儲中, 執行 git remote add origin \xa0 git@github.com:mdecourse/nfumde.git \xa0 後, .git/config 中將增加此一 git remote add 設定資料而成為: \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n \n \n \n [core] \n \xa0\xa0\xa0\xa0 repositoryformatversion = 0 \n \xa0\xa0\xa0\xa0 filemode =  false \n \xa0\xa0\xa0\xa0 bare =  false \n \xa0\xa0\xa0\xa0 logallrefupdates =  true \n \xa0\xa0\xa0\xa0 symlinks =  false \n \xa0\xa0\xa0\xa0 ignorecase =  true \n [remote  "origin" ] \n \xa0\xa0\xa0\xa0 url = git@github.com:mdecourse/nfumde.git \n \xa0\xa0\xa0\xa0 fetch = +refs/heads/*:refs/remotes/origin/* \n \n \n \n \n \n \n \n 當使用者在執行 git push --set-upstream origin main 或 git push -u origin main 時, 由於附加設定內建的 upstream 為 main 分支, 因此之後的 git push 與 git pull 若從 orgin 存取版本資料, 可以不用宣告分支, git 會假定存取 main 分支, 意即 git push 就是指 git push origin main. 此時.git/config 中將增加以下 upstream 設定: \n \n \n \n \n \n \n 1 \n 2 \n 3 \n \n \n \n [branch  "main" ] \n \xa0\xa0\xa0\xa0 remote = origin \n \xa0\xa0\xa0\xa0 merge = refs/heads/main \n \n \n \n \n \n \n \n 最後若再執行 heroku login -i 以及 heroku git:remote -a nfumde, 也就是針對 Heroku 中的 nfumde app 設定 git remote add, 則最後的 .git/config 將成為: \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n \n \n \n [core] \n \xa0\xa0\xa0\xa0 repositoryformatversion = 0 \n \xa0\xa0\xa0\xa0 filemode =  false \n \xa0\xa0\xa0\xa0 bare =  false \n \xa0\xa0\xa0\xa0 logallrefupdates =  true \n \xa0\xa0\xa0\xa0 symlinks =  false \n \xa0\xa0\xa0\xa0 ignorecase =  true \n [remote  "origin" ] \n \xa0\xa0\xa0\xa0 url = git@github.com:mdecourse/nfumde.git \n \xa0\xa0\xa0\xa0 fetch = +refs/heads/*:refs/remotes/origin/* \n [remote  "heroku" ] \n \xa0\xa0\xa0\xa0 url = https: //git.heroku.com/nfumde.git \n \xa0\xa0\xa0\xa0 fetch = +refs/heads/*:refs/remotes/heroku/* \n [branch  "main" ] \n \xa0\xa0\xa0\xa0 remote = origin \n \xa0\xa0\xa0\xa0 merge = refs/heads/main \n \n \n \n \n \n \n \n 現在假如連倉儲的 origin url 都選擇自行設定, 其步驟如下: \n \n 在近端命令視窗中, 以 git init (為了配合使用 main 作為主分支名稱, 可以使用 git config --global init.defaultBranch main 將設定寫入 home_ipv6\\.gitconfig 中) 建立空的倉儲, 取得 Github 空倉儲的 url 後, 可以採用 https 或 SSH 模式進行 git remote add 的設定. \n 假如遠端的 Github 倉儲使用者帳號為 mdecourse, 而空倉儲名稱為 nfumde, 則其 https 的 url 為\xa0 https://github.com/mdecourse/nfumde , \xa0 若採用 SSH 則其 url 為 \xa0 git@my_putty_session:mdecourse/nfumde.git \n 步驟 2. 的指令為 git remote add origin https://github.com/mdecourse/nfumde.git, 或者使用 git remote add origin git@my_putty_session:mdecourse/nfumde.git \n 另外若將此一倉儲在近端使用 Heroku 的指令與遠端的 Heroku 名稱為 nfumde 的 app 進行對應設定, 則命令在 heroku login -i 之後, 以 heroku git:remote -a nfumde, 之後就可以透過 git push heroku 將此一倉儲的版本推向 Heroku. \n \n 操作過程, 第一時間在近端以 git init 建立空倉儲時發現仍使用 master 作為主分支名稱, 因此利用 git config --global init.defaultBranch main 將設定存入 home_ipv6\\.gitconfig 中, 將主分支名稱設為 main. 畫面如下: \n \n 以上所完成的 Heroku 網際程式: \xa0 http://nfumde.herokuapp.com/table \n 假如要將上列網際程式改為 AJAX 模式, 可以參考下列程式碼, 以 button 的方式送出 AJAX 所需的 POST 變數: \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n 33 \n 34 \n 35 \n 36 \n 37 \n 38 \n 39 \n 40 \n 41 \n 42 \n 43 \n 44 \n 45 \n 46 \n 47 \n 48 \n 49 \n 50 \n 51 \n 52 \n 53 \n 54 \n 55 \n 56 \n 57 \n 58 \n 59 \n 60 \n 61 \n 62 \n 63 \n \n \n \n from   flask  import   (Flask, request, jsonify) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \n app  =   Flask(__name__) \n \xa0 \n html_page  =   """<!DOCTYPE HTML> \n <html> \n <head> \n <title>Rough AJAX Test</title> \n <script> \n \xa0\xa0\xa0\xa0 function loadXMLDoc() \n \xa0\xa0\xa0\xa0 { \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 var req = new XMLHttpRequest() \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 req.onreadystatechange = function() \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 { \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if (req.readyState == 4) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 { \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if (req.status != 200) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 { \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 //error handling code here \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 } \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 else \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 { \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 var response = JSON.parse(req.responseText) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 document.getElementById(\'myDiv\').innerHTML = response.username \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 } \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 } \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 } \n \xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 req.open(\'POST\', \'/ajax\') \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 req.setRequestHeader("Content-type", "application/x-www-form-urlencoded") \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 var un = document.getElementById(\'scname\').value \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 var sec = document.getElementById(\'secret\').value \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 var postVars = \'username=\'+un+\'&secret=\'+sec \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 req.send(postVars) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return false \n \xa0\xa0\xa0\xa0 } \n </script> \n </head> \n <body> \n <h1>Flask AJAX Test</h1> \n <form action="" method="POST"> \n <input type="text" name="scname" id="scname"> \n <input type="hidden" name="secret" id="secret" value="shhh"> \n <input type="button" value="Submit" onclick="return loadXMLDoc()"> \n </form> \n <div id="myDiv"></div> \n </body> \n </html>""" \n \xa0 \n @app .route( \'/\' ) \n def   index(): \n \xa0\xa0\xa0\xa0 return   html_page \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \n @app .route( \'/ajax\' , methods  =   [ \'POST\' ]) \n def   ajax_request(): \n \xa0\xa0\xa0\xa0 username  =   request.form[ \'username\' ] \n \xa0\xa0\xa0\xa0 return   jsonify(username = username) \n \xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 \xa0 \n if   __name__  = =   "__main__" : \n \xa0\xa0\xa0\xa0 app.run(debug  =   True ) \n \n \n \n \n \n \n \n 以上的 html 原始碼可以利用 \xa0 https://html-online.com/editor/ \xa0 進行編輯. \n', 'tags': '', 'url': 'W7.html'}, {'title': 'W8', 'text': '網際 RoboDK 程式 \n 下半學期的教學目標之三: \n 利用 \xa0 RoboDK \xa0 作為整合英文, 數學與網際內容管理相關技術的測試工具, 希望能夠透過網際程式控制特定的六軸機械手臂 ( 參考 , \xa0 Guide ). \n 官方 Pick and Place 範例: \xa0 https://github.com/mdecourse/wcm2021/tree/main/downloads/robodk/pick_and_place \n 自行利用 Python API 建立 station: \n 從 \xa0 https://github.com/mdecourse/wcm2021/tree/main/downloads/robodk/pick_and_place_kmol_mac \xa0 目錄, 可以使用 Python 建立 RoboDK station: \n 程式碼: \xa0 https://github.com/mdecourse/wcm2021/blob/main/downloads/robodk/pick_and_place_kmol_mac/pick_and_place_kmol.py \n 所完成的 station: \n \n RoboDK Forum: \xa0 https://robodk.com/forum \n Euler Angles: \xa0 https://www.mecademic.com/en/how-is-orientation-in-space-represented-with-euler-angles \n RoboDK-Doc-EN-Getting-Started.pdf \n https://en.wikipedia.org/wiki/Robotics_simulator \n https://github.com/RoboDK?tab=repositories \n https://robodk.com/doc/en/PythonAPI/ \n https://robodk.com/offline-programming \n https://robodk.com/doc/en/PythonAPI/robolink.html \n https://www.automate.org/news/9-powerful-robodk-features-you-might-not-know-about \n 2016_Flapping-wing mechanism for a bird-sizedUAVs design, modeling and control.pdf \n 2018_Implementation of a Simulation System for Additive Task Experiments.pdf \n 2019_Multi-Robot Collaboration.pdf \n 2019_3D Printing using an Industrial Robotic Arm and a Cellulose based filament.pdf \n 2019_Towards the Development of Safe, Collaborative RoboticFreehand Ultrasound.pdf \n 2020_Simulator for Articulate Robots.pdf \n 2020 Robot Adventures in Python and C.pdf \n https://vmayoral.github.io/robots,/ai,/deep/learning,/rl,/reinforcement/learning/2016/07/06/rl-intro/ \n Industrial_robots1.pdf \n IntroRobotKinematics5.pdf \n RoboDK 版本: \xa0 https://robodk.com/whatsnew \n RoboDK 5.2.2 安裝 \n 內定安裝於 c:\\robodk \n 可附帶安裝 Python 3.7.3, 並安裝 robodk 模組 \n 會先安裝 vcredist_x64_2017 \n 安裝版 30 天內可存檔, 必須 IPv4 上網才能取得 free trial 30 天權限. \n RoboDK 的 remote API 必須先 IPv4 上網後, 經官方網站確認 License 後, 才可啟動 API server, 否則只能在 localhost 上執行 API 操控. \n 電腦輔助設計室網路連線順序: \n \n 以 IPv4 NAT 連線, 啟動可攜 RoboDK 取得 limited 連線授權. \n 改以純 IPv6 網路連線, 內部建立 192.168.192.1XX 網路群, 按照組序與學員序取得 IPv4 固定網址. \n 各學員可以透過 Proxy 取得 Robot library 中的資料, 並且透過 remote API 進行網際協同操控. \n \n Setup and Interfacing of a KUKA RoboticsLab.pdf \n RoboDK API for Python: \n https://raw.githubusercontent.com/RoboDK/RoboDK-API/master/Python/robodk.py \n https://raw.githubusercontent.com/RoboDK/RoboDK-API/master/Python/robolink.py \n The robolink module is the bridge between RoboDK and Python. Every object in the RoboDK item tree can be retrieved and it is represented by the object Item. An item can be a robot, a reference frame, a tool, an object or any other item visible in the station tree. \n The following example uses the robodk and robolink libraries to move a robot. \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n \n \n \n from   robolink  import   * \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0  # import the robolink library (bridge with RoboDK) \n # 假如跨網路執行 Python remote API, 則提供位於遠端的 RoboDK server ip \n RDK  =   Robolink( \'server_ipv4_ip_address\' )\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0  # establish a link with the simulator \n robot  =   RDK.Item( \'ABB IRB 120-3/0.6\' )\xa0\xa0\xa0\xa0\xa0  # retrieve the robot by name \n robot.setJoints([ 0 , 0 , 0 , 0 , 0 , 0 ])\xa0\xa0\xa0\xa0\xa0  # set all robot axes to zero \n \xa0 \n target  =   RDK.Item( \'Target\' )\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0  # retrieve the Target item \n robot.MoveJ(target)\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0  # move the robot to the target \n \'\'\' \n # calculate a new approach position 100 mm along the Z axis of the tool with respect to the target \n from robodk import *\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # import the robodk library (robotics toolbox) \n approach = target.Pose()*transl(0,0,-100) \n robot.MoveL(approach)\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # linear move to the approach position \n \'\'\' \n \n \n \n \n \n \n \n 有關 Python struct: \xa0 https://docs.python.org/3/library/struct.html \n command line option: \xa0 https://robodk.com/doc/en/RoboDK-API-Command-Line-Options.html \n RDK = Robolink(args=\'-ADDFRAME "-RENAME=Main Ref " load_object.stl\') \n robolink modula: \xa0 https://robodk.com/doc/en/PythonAPI/robolink.html#robolink.Robolink.ShowRoboDK \n RoboDK Mac 最新版安裝檔: \xa0 https://robodk.com/downloads/Install-RoboDK.dmg \n RoboDK Linux 最新安裝檔: \xa0 https://robodk.com/downloads/install-robodk-64.tar.gz \n RoboDK 透過遠端桌面執行: \n 由於顯示卡硬體功能受到限制, 因此透過 remote desktop 執行 RoboDK 時, 必須使用 C:/RoboDK/RoboDK-Safe-Start-VM.bat 啟動 RoboDK, 批次檔案內容如下: \n \n \n \n \n \n \n 1 \n 2 \n 3 \n \n \n \n cd bin \n set QT_OPENGL=software \n start  ""   RoboDK-GL2.exe -DEBUG -SKIPINI \n \n \n \n \n \n \n \n RoboDK allow external API ( reference ): \n 目前 RoboDK 的 \xa0 https://raw.githubusercontent.com/RoboDK/RoboDK-API/master/Python/robolink.py \xa0 僅支援 IPv4, 必須將 socket 傳送改為 IPv6, 可參考: \xa0 https://hub.packtpub.com/ipv6-unix-domain-sockets-and-network-interfaces/ \n 假如要在電腦輔助設計室中跨網路執行 RoboDK remote API, 可以在 IPv6 環境下創建一個內部 IPv4 群網路進行測試. \n 設定 RoboDK remote API 位於 Tools - Options - Other - RoboDK API, 啟動 RoboDK remote API server 後, 必須讓 RoboDK 通過操作系統的防火牆. \n RoboDK on Virtualbox ( reference ): \n I recommend you to start RoboDK by selecting: C:/RoboDK/RoboDK-Safe-Start-VM.bat Make sure to install graphic card drivers and allocate hardware accelerated GPU with support for OpenGL, if possible. If it fails, we can better debug this issue by following these steps. \xa0\xa0\xa0 Start RoboDK by double clicking the file: \xa0\xa0\xa0 C:/RoboDK/RoboDK-Debug.bat \xa0\xa0\xa0 Try to reproduce the problem in RoboDK until it crashes. \xa0\xa0\xa0 Right after the crash, provide the following file: \xa0\xa0\xa0 C:/RoboDK/bin/RoboDK.debug.txt \n Hint: \n MoveJ(self, target, blocking=True) \xa0 reference Moves a robot to a specific target ("Move Joint" mode). self function blocks until the robot finishes its movements. In\xa0 1 : joints/pose/item -> target to move to. It can be the robot joints (Nx1 or 1xN), the pose (4x4) or an item (item pointer) In\xa0 2 (optional): blocking -> True if we want the instruction to wait until the robot finished the movement (default=True) \n add Camera: \xa0 https://robodk.com/doc/en/PythonAPI/robolink.html#robolink.Robolink.Cam2D_Add \n Temp py programs: \n https://robodk.com/forum/Thread-Convert-a-main-program-to-a-python-script \n Set Robot base: \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n \n \n \n RDK  =   robolink() \n \xa0 \n robot_base  =   RDK.Item( \'Robot Base Name\' , ITEM_TYPE_FRAME) \n robot_base.setPose( 4x4   mat with the position) \n \n \n \n \n \n \n \n 參考: \n 提供原始碼的 \xa0 http://animatlab.com/ \n', 'tags': '', 'url': 'W8.html'}, {'title': 'W9', 'text': '打期望分數 \n', 'tags': '', 'url': 'W9.html'}, {'title': 'W10', 'text': '網際內容管理系統下半學期將有以下幾個主要教學目標: \n \n 對 \xa0 Python Flask 網際程式 的架構能夠更加深入了解, 各學員不僅會利用 \xa0 Beautifulsoup \xa0 從學校教務主機擷取資料, 建立 \xa0 Heroku \xa0 雲端應用程式, 列出各實驗室的排課資訊外, 能計算各實驗室的排課總時數, 同時也能將查得的資料分別存入 SQLite 與 PostgreSQL 資料庫 (flaskg 範例 倉儲 與 網站 ). \n 要求學員有能力 自行編寫 如 網際猜拳 , \xa0 網際英英字典 \xa0 ( http://lookupdict.herokuapp.com , 採 scrum1 At mde 部署), 以及其他與 機械設計較相關的網際程式 \xa0 (包括 猜數字遊戲 , \xa0 正齒輪齒面寬設計 , \xa0 2D 繪圖 等). \n 利用 \xa0 RoboDK \xa0 作為整合英文, 數學與網際內容管理相關技術的測試工具, 希望能夠透過網際程式控制特定的六軸機械手臂 ( 參考 , \xa0 Guide ). \n 編寫能夠協助 CMSiMDE \xa0 分頁 錯誤時進行 debug 的 輔助程式 \xa0 (擬採用 \xa0 https://github.com/PySimpleGUI/PySimpleGUI \xa0 or \xa0 https://github.com/dddomodossola/remi \xa0 進行測試), 假如要讓 CMSiMDE 能夠透過中文斷字 ( https://github.com/fxsjy/jieba ), 試著解讀網際內容管理的關鍵字, 進而了解網站的內容屬性. \n \n 根據下圖所示, 四年前所部署的 \xa0 https://wcms-scrum1.herokuapp.com/ \xa0 所使用的 The Heroku-16 stack is deprecated, 意即 \xa0 Heroku-16 stack \xa0 將要在 2021.06.01 終止 build 功能, 因此部署在此雲端硬體平台的應用程式, 若要持續改版, 必須要在生命週期結束之前搬遷到其他硬體平台上: \n \n SQLite 練習 \n 目的希望能將之前所寫的各實驗室排課表網際程式, 能將所查詢的資料存入 SQLite, 並且部署到 Heroku. \n 之後再將資料庫應用至 PostgreSQL, 最後再將網際資料庫程式部署到 Heroku. \n 若該網際程式配置 Oauth2 的登入套件, 即可延伸應用至各實驗室上課時段外的實驗室借用管理系統. 若再利用雲端點名系統 RFID 掃描的感應開門, 將可擴大此系統的應用範圍. \n', 'tags': '', 'url': 'W10.html'}, {'title': 'W11', 'text': '1. OBS + Youtube 分組直播錄影測試: \n 首次進行 Youtube 直播需要等待 24 小時後才可啟用. \n 假如是在 Mac 環境安裝 OBS, 必須至 System Preferences - Security & Privacy 處允許 OBS 使用 Camera 與 Screen Recording. \n 在 IPv6 環境下進行各分組桌面操作直播錄影 \n 登入 @gm 帳號後連結至 Youtube 選擇 Live stream, 取得直播金鑰 \n 將直播金鑰輸入 OBS, 啟動顯示器擷取, 透過串流訊號將桌面操作影像傳至 Youtube 進行直播錄影. \n 根據 \xa0 http://mde.tw/cd2021/content/task2.html \xa0 進行 IPv6 + 區域網路操控進行測試. \n 參考 \xa0 http://mde.tw/cd2021/content/task3.html \xa0 使用各組網際簡報內容引導直撥錄影. \n 2. 各分組從 \xa0 http://mde.tw/wcm2021/content/W10.html \xa0 網際程式中選擇一項, 負責從近端執行部署至 Heroku. \n 自行利用 Ubuntu 建立可啟動 CMSiMDE 動態系統與 Fossil SCM 伺服器的目的: \n 建立完整的 Python 網際程式開發環境. \n 開發的程式碼可採用 Fossil SCM 與 Github 同步的方式進行分散式版次管理. \n Ubuntu 20.04 on Virtualbox, 從 \xa0 http://a.kmol.info:88/Ub2004.vdi \xa0 取得 已經安裝 Ubuntu 的虛擬硬碟進行後續設定. 或者自行下載 Ubuntu 20.04 Desktop 版 iso 檔案自行安裝帶有桌面的虛擬主機. \n 先更改 vdi 的 uuid : \n \n \n \n \n \n \n 1 \n \n \n \n "c:\\Program Files\\Oracle\\VirtualBox\\VBoxManage.exe"   internalcommands sethduuid Ubwcm2021.vdi \n \n \n \n \n \n \n \n 設定虛擬主機網路連線: \n 接著將 Ubuntu 虛擬主機的網路以 Bridged 串接到 Windows 10 已經連線的網路卡. \n 登入系統後進行更新: \n 由於 /etc/netplan/net.yaml 中採用 DHCP6 連外, 因此透過 ifconfig 可以取得網路連線資訊. \n 但因電腦輔助設計室採純 IPv6 設定, 因此必須透過雙網路協定代理主機上網才可執行下列 apt 指令. \n 因此要以 sudo vi\xa0 /etc/apt/apt.conf 建立 \xa0 apt 代理主機設定檔 , 內容如下: \n \n \n \n \n \n \n 1 \n \n \n \n Acquire::http::Proxy  "http://proxy_username:proxy_password@[Proxy_server_ipv6_address]:3128" ; \n \n \n \n \n \n \n \n 之後就可以完成下列更新指令執行: \n sudo apt update \n sudo apt upgrade \n sudo apt autoremove \n', 'tags': '', 'url': 'W11.html'}, {'title': 'W12', 'text': '全不懂老師在說甚麼，robodk、虛擬網站、FileZillaPortable、Oracle VM VirtualBox一大堆不明白的東西進入腦子，只能勉強記憶下來，回去再好好消化。 \n 回去想辦法處理robodk看了影片還是完全不懂，只好求助同學跟私訊老師，而虛擬網站之後的只是更加糟糕。 \n', 'tags': '', 'url': 'W12.html'}, {'title': 'W13', 'text': 'Pick and Place 檔案下載 \n 可攜程式系統的命令列視窗輸入 pip install robodk\xa0 \n \n 開啟robodk(記得要前往 工具/選項/其他/打勾允許外部AIP並且輸入目前電腦網路IP \n pick_and_place除程式碼都拉近robodk \n \n 開啟Python-robodk-Install.bat(robodk下 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n \n \n \n :: cd Python \n \xa0 \n :: Install RoboDK API \n python.exe  - m pip install\xa0  "./Python/."   - I \n \xa0 \n :: Install pylint (linting  for   VScode) \n python.exe  - m pip install  "pylint>=2.3"   - - retries = 2 \n \xa0 \n :: Install rope (easy variable renaming  in   VScode) \n python.exe  - m pip install  "rope>=0.14"   - - retries = 2 \n \xa0 \n :: Display  all   installed packages \n python.exe Python_Versions.py \n \xa0 \n pause \n \n \n \n \n \n \n \n 和apick_and_place.py(注意go之前IP要設定目前連線網路的IP \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n 33 \n 34 \n 35 \n 36 \n 37 \n 38 \n 39 \n 40 \n 41 \n 42 \n 43 \n 44 \n 45 \n 46 \n 47 \n 48 \n 49 \n 50 \n 51 \n 52 \n 53 \n 54 \n 55 \n 56 \n 57 \n 58 \n 59 \n 60 \n 61 \n 62 \n 63 \n 64 \n 65 \n 66 \n 67 \n 68 \n 69 \n 70 \n 71 \n 72 \n 73 \n 74 \n 75 \n 76 \n 77 \n 78 \n 79 \n 80 \n 81 \n 82 \n 83 \n 84 \n 85 \n 86 \n 87 \n 88 \n 89 \n 90 \n 91 \n 92 \n 93 \n 94 \n 95 \n 96 \n 97 \n 98 \n 99 \n 100 \n 101 \n 102 \n 103 \n 104 \n 105 \n 106 \n 107 \n 108 \n 109 \n 110 \n 111 \n 112 \n 113 \n 114 \n 115 \n 116 \n 117 \n 118 \n 119 \n 120 \n 121 \n 122 \n 123 \n 124 \n 125 \n 126 \n 127 \n 128 \n 129 \n 130 \n 131 \n 132 \n 133 \n 134 \n 135 \n 136 \n 137 \n 138 \n 139 \n 140 \n 141 \n 142 \n 143 \n 144 \n 145 \n 146 \n 147 \n 148 \n 149 \n 150 \n 151 \n 152 \n 153 \n 154 \n 155 \n 156 \n 157 \n 158 \n 159 \n 160 \n 161 \n 162 \n 163 \n 164 \n 165 \n 166 \n 167 \n 168 \n 169 \n 170 \n 171 \n 172 \n 173 \n 174 \n 175 \n 176 \n 177 \n 178 \n 179 \n 180 \n 181 \n 182 \n 183 \n 184 \n 185 \n 186 \n 187 \n \n \n \n # KMOLab Portable RoboDK pick and place \n from   robolink  import   * \xa0\xa0\xa0  # API to communicate with robodk \n from   robodk  import   * \xa0\xa0\xa0\xa0\xa0  # robodk robotics toolbox \n \xa0 \n # Setup global parameters \n BALL_DIAMETER  =   100   # diameter of one ball \n APPROACH  =   100 \xa0\xa0\xa0\xa0\xa0  # approach distance to grab each part, in mm \n nTCPs  =   6 \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0  # number of TCP\'s in the tool \n \xa0 \n #---------------------------------------------- \n # Function definitions \n \xa0 \n def   box_calc(BALLS_SIDE = 4 , BALLS_MAX = None ): \n \xa0\xa0\xa0\xa0 """Calculate a list of points (ball center) as if the balls were stored in a box""" \n \xa0\xa0\xa0\xa0 if   BALLS_MAX  is   None : BALLS_MAX  =   BALLS_SIDE * * 3 \n \xa0\xa0\xa0\xa0 xyz_list  =   [] \n \xa0\xa0\xa0\xa0 for   h  in   range (BALLS_SIDE): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 for   i  in   range (BALLS_SIDE): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 for   j  in   range (BALLS_SIDE): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 xyz_list  =   xyz_list  +   [[(i + 0.5 ) * BALL_DIAMETER, (j + 0.5 ) * BALL_DIAMETER, (h + 0.5 ) * BALL_DIAMETER]] \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   len (xyz_list) > =   BALLS_MAX: \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return   xyz_list \n \xa0\xa0\xa0\xa0 return   xyz_list \n \xa0 \n def   pyramid_calc(BALLS_SIDE = 4 ): \n \xa0\xa0\xa0\xa0 """Calculate a list of points (ball center) as if the balls were place in a pyramid""" \n \xa0\xa0\xa0\xa0 #the number of balls can be calculated as: int(BALLS_SIDE*(BALLS_SIDE+1)*(2*BALLS_SIDE+1)/6) \n \xa0\xa0\xa0\xa0 BALL_DIAMETER  =   100 \n \xa0\xa0\xa0\xa0 xyz_list  =   [] \n \xa0\xa0\xa0\xa0 sqrt2  =   2 * * ( 0.5 ) \n \xa0\xa0\xa0\xa0 for   h  in   range (BALLS_SIDE): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 for   i  in   range (BALLS_SIDE - h): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 for   j  in   range (BALLS_SIDE - h): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 height  =   h * BALL_DIAMETER / sqrt2  +   BALL_DIAMETER / 2 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 xyz_list  =   xyz_list  +   [[i * BALL_DIAMETER  +   (h + 1 ) * BALL_DIAMETER * 0.5 , j * BALL_DIAMETER  +   (h + 1 ) * BALL_DIAMETER * 0.5 , height]] \n \xa0\xa0\xa0\xa0 return   xyz_list \n \xa0 \n def   balls_setup(frame, positions): \n \xa0\xa0\xa0\xa0 """Place a list of balls in a reference frame. The reference object (ball) must have been previously copied to the clipboard.""" \n \xa0\xa0\xa0\xa0 nballs  =   len (positions) \n \xa0\xa0\xa0\xa0 step  =   1.0 / (nballs  -   1 ) \n \xa0\xa0\xa0\xa0 for   i  in   range (nballs): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 newball  =   frame.Paste() \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 newball.setName( \'ball \'   +   str (i))  #set item name \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 newball.setPose(transl(positions[i]))  #set item position with respect to parent \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 newball.setVisible( True ,  False )  #make item visible but hide the reference frame \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 newball.Recolor([ 1 - step * i, step * i,  0.2 ,  1 ])  #set RGBA color \n \xa0 \n def   cleanup_balls(parentnodes): \n \xa0\xa0\xa0\xa0 """Delete all child items whose name starts with \\"ball\\", from the provided list of parent items.""" \n \xa0\xa0\xa0\xa0 todelete  =   [] \n \xa0\xa0\xa0\xa0 for   item  in   parentnodes: \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 todelete  =   todelete  +   item.Childs() \n \xa0 \n \xa0\xa0\xa0\xa0 for   item  in   todelete: \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   item.Name().startswith( \'ball\' ): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 item.Delete() \n \xa0 \n def   TCP_On(toolitem, tcp_id): \n \xa0\xa0\xa0\xa0 """Attach the closest object to the toolitem Htool pose, \n \xa0\xa0\xa0\xa0 furthermore, it will output appropriate function calls on the generated robot program (call to TCP_On)""" \n \xa0\xa0\xa0\xa0 toolitem.AttachClosest() \n \xa0\xa0\xa0\xa0 toolitem.RDK().RunMessage( \'Set air valve %i on\'   %   (tcp_id + 1 )) \n \xa0\xa0\xa0\xa0 toolitem.RDK().RunProgram( \'TCP_On(%i)\'   %   (tcp_id + 1 )); \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \n def   TCP_Off(toolitem, tcp_id, itemleave = 0 ): \n \xa0\xa0\xa0\xa0 """Detaches the closest object attached to the toolitem Htool pose, \n \xa0\xa0\xa0\xa0 furthermore, it will output appropriate function calls on the generated robot program (call to TCP_Off)""" \n \xa0\xa0\xa0\xa0 toolitem.DetachAll(itemleave) \n \xa0\xa0\xa0\xa0 toolitem.RDK().RunMessage( \'Set air valve %i off\'   %   (tcp_id + 1 )) \n \xa0\xa0\xa0\xa0 toolitem.RDK().RunProgram( \'TCP_Off(%i)\'   %   (tcp_id + 1 )); \n \xa0 \n \xa0 \n #---------------------------------------------------------- \n # The program starts here: \n \xa0 \n # Any interaction with RoboDK must be done through RDK: \n RDK  =   Robolink(robodk_path = "C:/robodk\\robodk522_portable/bin/RoboDK.exe" , robodk_ip = \'192.168.1.111\' ) \n \xa0 \n # Turn off automatic rendering (faster) \n RDK.Render( False ) \n \xa0 \n #RDK.Set_Simulation_Speed(500); # set the simulation speed \n \xa0 \n # Gather required items from the station tree \n robot  =   RDK.Item( \'Fanuc M-710iC/50\' ) \n robot_tools  =   robot.Childs() \n #robottool = RDK.Item(\'MainTool\') \n frame1  =   RDK.Item( \'Table 1\' ) \n frame2  =   RDK.Item( \'Table 2\' ) \n \xa0 \n # Copy a ball as an object (same as CTRL+C) \n ballref  =   RDK.Item( \'reference ball\' ) \n ballref.Copy() \n \xa0 \n # Run a pre-defined station program (in RoboDK) to replace the two tables \n prog_reset  =   RDK.Item( \'Replace objects\' ) \n prog_reset.RunProgram() \n \xa0 \n # Call custom procedure to remove old objects \n cleanup_balls([frame1, frame2]) \n \xa0 \n # Make a list of positions to place the objects \n frame1_list  =   pyramid_calc( 4 ) \n frame2_list  =   pyramid_calc( 4 ) \n \xa0 \n # Programmatically place the objects with a custom-made procedure \n balls_setup(frame1, frame1_list) \n \xa0 \n # Delete previously generated tools \n for   tool  in   robot_tools: \n \xa0\xa0\xa0\xa0 if   tool.Name().startswith( \'TCP\' ): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 tool.Delete() \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \n # Calculate tool frames for the suction cup tool of 6 suction cups \n TCP_list  =   [] \n for   i  in   range (nTCPs): \n \xa0\xa0\xa0\xa0 TCPi_pose  =   transl( 0 , 0 , 100 ) * rotz(( 360 / nTCPs) * i * pi / 180 ) * transl( 125 , 0 , 0 ) * roty(pi / 2 ) \n \xa0\xa0\xa0\xa0 TCPi  =   robot.AddTool(TCPi_pose,  \'TCP %i\'   %   (i + 1 )) \n \xa0\xa0\xa0\xa0 TCP_list.append(TCPi) \n \xa0 \n TCP_0  =   TCP_list[ 0 ] \n \xa0 \n # Turn on automatic rendering \n RDK.Render( True ) \n \xa0 \n # Move balls\xa0\xa0\xa0  \n robot.setPoseTool(TCP_list[ 0 ]) \n nballs_frame1  =   len (frame1_list) \n nballs_frame2  =   len (frame2_list) \n idTake  =   nballs_frame1  -   1 \n idLeave  =   0 \n idTCP  =   0 \n target_app_frame  =   transl( 2 * BALL_DIAMETER,  2 * BALL_DIAMETER,  4 * BALL_DIAMETER) * roty(pi) * transl( 0 , 0 , - APPROACH) \n \xa0 \n while   idTake > =   0 : \n \xa0\xa0\xa0\xa0 # ------------------------------------------------------------------ \n \xa0\xa0\xa0\xa0 # first priority: grab as many balls as possible \n \xa0\xa0\xa0\xa0 # the tool is empty at this point, so take as many balls as possible (up to a maximum of 6 -> nTCPs) \n \xa0\xa0\xa0\xa0 ntake  =   min (nTCPs, idTake  +   1 ) \n \xa0 \n \xa0\xa0\xa0\xa0 # approach to frame 1 \n \xa0\xa0\xa0\xa0 robot.setPoseFrame(frame1) \n \xa0\xa0\xa0\xa0 robot.setPoseTool(TCP_0) \n \xa0\xa0\xa0\xa0 robot.MoveJ([ 0 , 0 , 0 , 0 , 10 , - 200 ]) \n \xa0\xa0\xa0\xa0 robot.MoveJ(target_app_frame) \n \xa0 \n \xa0\xa0\xa0\xa0 # grab ntake balls from frame 1 \n \xa0\xa0\xa0\xa0 for   i  in   range (ntake): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 TCPi  =   TCP_list[i] \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 robot.setPoseTool(TCPi) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # calculate target wrt frame1: rotation about Y is needed since Z and X axis are inverted \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 target  =   transl(frame1_list[idTake]) * roty(pi) * rotx( 30 * pi / 180 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 target_app  =   target * transl( 0 , 0 , - APPROACH) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 idTake  =   idTake  -   1 \xa0\xa0\xa0\xa0\xa0\xa0\xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 robot.MoveL(target_app) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 robot.MoveL(target) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 TCP_On(TCPi, i) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 robot.MoveL(target_app) \n \xa0 \xa0 \n \xa0\xa0\xa0\xa0 # ------------------------------------------------------------------ \n \xa0\xa0\xa0\xa0 # second priority: unload the tool\xa0\xa0\xa0\xa0  \n \xa0\xa0\xa0\xa0 # approach to frame 2 and place the tool balls into table 2 \n \xa0\xa0\xa0\xa0 robot.setPoseTool(TCP_0) \n \xa0\xa0\xa0\xa0 robot.MoveJ(target_app_frame) \n \xa0\xa0\xa0\xa0 robot.MoveJ([ 0 , 0 , 0 , 0 , 10 , - 200 ]) \n \xa0\xa0\xa0\xa0 robot.setPoseFrame(frame2)\xa0\xa0\xa0  \n \xa0\xa0\xa0\xa0 robot.MoveJ(target_app_frame) \n \xa0\xa0\xa0\xa0 for   i  in   range (ntake): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 TCPi  =   TCP_list[i] \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 robot.setPoseTool(TCPi) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   idLeave > nballs_frame2 - 1 : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 raise   Exception( "No room left to place objects in Table 2" ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # calculate target wrt frame1: rotation of 180 about Y is needed since Z and X axis are inverted \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 target  =   transl(frame2_list[idLeave]) * roty(pi) * rotx( 30 * pi / 180 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 target_app  =   target * transl( 0 , 0 , - APPROACH) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 idLeave  =   idLeave  +   1 \xa0\xa0\xa0\xa0\xa0\xa0\xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 robot.MoveL(target_app) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 robot.MoveL(target) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 TCP_Off(TCPi, i, frame2) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 robot.MoveL(target_app) \n \xa0 \n \xa0\xa0\xa0\xa0 robot.MoveJ(target_app_frame) \n \xa0 \n # Move home when the robot finishes \n robot.MoveJ([ 0 , 0 , 0 , 0 , 10 , - 200 ]) \n \n \n \n \n \n \n \n', 'tags': '', 'url': 'W13.html'}, {'title': 'W14', 'text': '分組組員創建共同倉儲 \n', 'tags': '', 'url': 'W14.html'}, {'title': 'W15', 'text': '創建分組倉儲 \n 倉儲: https://40923148.github.io/wcm2021-ag4/content/index.html \n \n', 'tags': '', 'url': 'W15.html'}]};